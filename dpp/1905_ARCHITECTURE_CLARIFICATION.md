# 1905 握手与 Driver Offload 的共存之道

您提出的顾虑非常专业：**如果底层驱动/固件已经接管了 WPA2 (Offload)，我们上层再跑一套状态机，会不会打架？驱动会认吗？**

答案是：**完全可以复用，且不会打架。** 秘密在于我们在 `eap1905.c` 中设计的 **"Fake Hostapd" + "Dummy Driver"** 架构。

## 1. 核心思想：解耦 (Decoupling)

即使物理网卡开启了 WPA2 Offload，它的本质是：
*   **Driver/Firmware**: 负责 *标准 Wi-Fi 接入* (SSID 广播, 手机连接) 的握手。
*   **eap1905 模块**: 负责 *1905 EasyMesh Backhaul* 的握手。

这两者运行在**完全平行**的轨道上。

### 1.1 我们并不是在操作“那个”网卡
在 `eap1905.c` 中，我们并没有使用 `hapd->driver` (真正的网卡驱动接口) 来初始化我们的状态机。

我们做了一件“偷天换日”的事情：
1.  **创建替身**: `eap1905_create_fake_hapd` 创建了一个全新的 `struct hostapd_data` 实例。
2.  **欺骗状态机**: 我们把这个替身的 `driver` 指针指向了 `dummy_driver_ops` (一个空壳驱动)。
3.  **运行逻辑**: 当 WPA 状态机 (`wpa_auth.c`) 想要发包或设 Key 时，它调用的是这个空壳驱动。

**结果**: 真正的物理网卡驱动根本**不知道**上面还有一个 WPA 状态机在跑。它只管它自己的 WPA2 Offload 任务。

## 2. 1905 握手的特殊性：Overlay 网络

1905 协议（Multi-AP）本身就是一种 **Overlay (覆盖层)** 协议。
*   **传输层**: 它的 EAPOL 帧往往不是直接通过 802.11 物理层作为“管理帧”发送的，而是封装在 **UDP** 或者 **Ethernet Frames** (比如 0x893a 1905 协议) 中传输的。
*   **这就是为什么需要 UDP**: 您的架构中，外部程序 (`map`) 负责收发网络包，通过 UDP 把 EAPOL 数据喂给我们的 `eap1905` 模块。

**流程对比**:

| 动作 | 标准 WPA2 (Driver Offload) | 1905 WPA (Software Engine) |
| :--- | :--- | :--- |
| **收包** | 网卡固件直接处理 Auth/Assoc | `map` 收到报文 -> UDP -> `eap1905` |
| **握手** | 固件内部状态机流转 | `eap1905` 内的 `wpa_sm` 流转 |
| **发包** | 固件直接发 802.11 帧 | `wpa_sm` -> `dummy_send` -> UDP -> `map` 发出去 |
| **结果** | 固件自己在硬件表里装 Key | `dummy_set_key` 截获 Key -> 我们可以手动下发给驱动 |

## 3. 驱动“认”什么？

驱动确实不认我们跑的这个状态机，但它认 **Key (密钥)**。

在 1905 流程结束后，我们的 `dummy_driver_ops->set_key` 会拿到最终算好的 PTK。此时，我们有权决定如何处理这个 Key：
1.  **如果这是无线回程**: 我们通过 Netlink/nl80211 命令（绕过 Hostapd 的常规流程）把 Key 下发给驱动，告诉它：“对于这个 Peer MAC，请使用这个 Key 进行加密”。驱动只认 Key，不问出处。
2.  **如果这是有线/逻辑认证**: 我们甚至不需要告诉驱动，只需要上报给 `map` 控制器：“认证通过，Key 是这个”。

## 4. 总结

您之所以觉得会“打架”，是因为潜意识里认为**一个接口只能有一个管理者**。

但实际上：
*   **Hostapd 主进程**: 管理**用户接入** (Fronthaul)，可能使用 Driver Offload。
*   **eap1905 模块**: 作为一个**独立的计算库**，借用了 hostapd 的代码逻辑，在内存里跑了一遍握手流程。它**不占用**物理硬件资源，只负责“算”出密钥。

这就好比：虽然您的显卡（Driver）自带了视频解码功能（Offload），但您依然可以在 CPU 上运行一个软件播放器（eap1905），两者互不干扰。只要最后显示的画面（Connectivity）是对的就行。
